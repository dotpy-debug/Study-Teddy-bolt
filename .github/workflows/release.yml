name: Release Management

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
        - prerelease
        - custom
      custom_version:
        description: 'Custom version (only if release_type is custom)'
        required: false
        type: string
      skip_tests:
        description: 'Skip tests for emergency releases'
        required: false
        default: false
        type: boolean
      create_release_notes:
        description: 'Generate release notes'
        required: false
        default: true
        type: boolean

env:
  NODE_VERSION: '20'
  BUN_VERSION: 'latest'

jobs:
  # Determine release version and strategy
  determine-version:
    name: Determine Release Version
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      previous_version: ${{ steps.version.outputs.previous_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install semantic-release
        run: |
          npm install -g semantic-release@latest
          npm install -g @semantic-release/changelog@latest
          npm install -g @semantic-release/git@latest
          npm install -g @semantic-release/github@latest
          npm install -g conventional-changelog-cli@latest

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Determine next version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"

            if [[ "$RELEASE_TYPE" == "custom" ]]; then
              NEW_VERSION="${{ github.event.inputs.custom_version }}"
              if [[ -z "$NEW_VERSION" ]]; then
                echo "Error: Custom version is required when release_type is custom"
                exit 1
              fi
            else
              # Calculate next version based on release type
              IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
              case "$RELEASE_TYPE" in
                "major")
                  NEW_VERSION="$((major + 1)).0.0"
                  ;;
                "minor")
                  NEW_VERSION="$major.$((minor + 1)).0"
                  ;;
                "patch")
                  NEW_VERSION="$major.$minor.$((patch + 1))"
                  ;;
                "prerelease")
                  NEW_VERSION="$major.$minor.$((patch + 1))-rc.$(date +%Y%m%d%H%M%S)"
                  ;;
              esac
            fi
          else
            # Automatic versioning based on conventional commits
            NEW_VERSION=$(semantic-release --dry-run | grep "next release version is" | sed 's/.*next release version is //' || echo "$CURRENT_VERSION")

            # If semantic-release didn't determine a new version, default to patch
            if [[ "$NEW_VERSION" == "$CURRENT_VERSION" ]]; then
              IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
              NEW_VERSION="$major.$minor.$((patch + 1))"
            fi
          fi

          # Validate version format
          if [[ ! $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
            echo "Error: Invalid version format: $NEW_VERSION"
            exit 1
          fi

          # Check if it's a prerelease
          IS_PRERELEASE="false"
          if [[ $NEW_VERSION =~ -.*$ ]]; then
            IS_PRERELEASE="true"
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT

          echo "Previous version: $CURRENT_VERSION"
          echo "New version: $NEW_VERSION"
          echo "Is prerelease: $IS_PRERELEASE"

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog between versions
          PREVIOUS_TAG="v${{ steps.version.outputs.previous_version }}"
          if ! git rev-parse "$PREVIOUS_TAG" >/dev/null 2>&1; then
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          # Generate conventional changelog
          CHANGELOG=$(conventional-changelog -p angular -u 2>/dev/null || echo "Initial release")

          # Format changelog for GitHub release
          FORMATTED_CHANGELOG=$(cat << 'EOF'
          ## What's Changed

          $CHANGELOG

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...v${{ steps.version.outputs.version }}
          EOF
          )

          # Store changelog in output (escape for JSON)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$FORMATTED_CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # Quality gates (only if not skipping tests)
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [determine-version]
    if: github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run tests
        run: bun run test

      - name: Run lint
        run: bun run lint

      - name: Type check
        run: bun run typecheck

      - name: Build check
        run: bun run build

  # Security scan for release
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [determine-version]
    if: github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Check for critical vulnerabilities
        run: |
          CRITICAL_COUNT=$(cat trivy-results.sarif | jq '[.runs[].results[].ruleId] | map(select(contains("CRITICAL"))) | length')
          if [[ $CRITICAL_COUNT -gt 0 ]]; then
            echo "Found $CRITICAL_COUNT critical vulnerabilities. Release blocked."
            exit 1
          fi

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [determine-version, quality-gates, security-scan]
    if: always() && (needs.quality-gates.result == 'success' || needs.quality-gates.result == 'skipped') && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')

    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      release_url: ${{ steps.create_release.outputs.html_url }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create and push tag
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"

      - name: Create GitHub Release
        id: create_release
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ needs.determine-version.outputs.version }}
          name: Release v${{ needs.determine-version.outputs.version }}
          body: ${{ needs.determine-version.outputs.changelog }}
          draft: false
          prerelease: ${{ needs.determine-version.outputs.is_prerelease }}
          generateReleaseNotes: ${{ github.event.inputs.create_release_notes || 'true' }}
          token: ${{ secrets.GITHUB_TOKEN }}

  # Build and attach release artifacts
  build-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [determine-version, create-release]

    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract platform info
        id: platform
        run: |
          PLATFORM="${{ matrix.platform }}"
          ARCH=$(echo $PLATFORM | cut -d'/' -f2)
          echo "arch=$ARCH" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/backend
          platforms: ${{ matrix.platform }}
          push: true
          tags: |
            ghcr.io/${{ github.repository }}/backend:v${{ needs.determine-version.outputs.version }}
            ghcr.io/${{ github.repository }}/backend:latest
          labels: |
            org.opencontainers.image.title=StudyTeddy Backend
            org.opencontainers.image.description=StudyTeddy Backend API
            org.opencontainers.image.version=v${{ needs.determine-version.outputs.version }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/frontend
          platforms: ${{ matrix.platform }}
          push: true
          tags: |
            ghcr.io/${{ github.repository }}/frontend:v${{ needs.determine-version.outputs.version }}
            ghcr.io/${{ github.repository }}/frontend:latest
          labels: |
            org.opencontainers.image.title=StudyTeddy Frontend
            org.opencontainers.image.description=StudyTeddy Frontend Application
            org.opencontainers.image.version=v${{ needs.determine-version.outputs.version }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ github.repository }}/backend:v${{ needs.determine-version.outputs.version }}
          format: spdx-json
          output-file: backend-sbom-${{ steps.platform.outputs.arch }}.spdx.json

      - name: Upload SBOM to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: backend-sbom-${{ steps.platform.outputs.arch }}.spdx.json
          asset_name: backend-sbom-${{ steps.platform.outputs.arch }}.spdx.json
          asset_content_type: application/json

  # Create Kubernetes manifests
  create-k8s-manifests:
    name: Create Kubernetes Manifests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [determine-version, create-release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate Kubernetes manifests
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"

          # Create release manifests directory
          mkdir -p release-manifests

          # Update image tags in Kubernetes manifests
          for env in staging production; do
            mkdir -p "release-manifests/$env"

            # Copy base manifests
            cp -r "k8s/$env/"* "release-manifests/$env/" 2>/dev/null || true

            # Update image tags
            find "release-manifests/$env" -name "*.yaml" -type f -exec sed -i "s|{{BACKEND_IMAGE}}|ghcr.io/${{ github.repository }}/backend:v$VERSION|g" {} \;
            find "release-manifests/$env" -name "*.yaml" -type f -exec sed -i "s|{{FRONTEND_IMAGE}}|ghcr.io/${{ github.repository }}/frontend:v$VERSION|g" {} \;
            find "release-manifests/$env" -name "*.yaml" -type f -exec sed -i "s|{{VERSION}}|$VERSION|g" {} \;
          done

          # Create tar archive
          tar -czf k8s-manifests-v$VERSION.tar.gz release-manifests/

      - name: Upload Kubernetes manifests to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: k8s-manifests-v${{ needs.determine-version.outputs.version }}.tar.gz
          asset_name: k8s-manifests-v${{ needs.determine-version.outputs.version }}.tar.gz
          asset_content_type: application/gzip

  # Create Helm chart
  create-helm-chart:
    name: Create Helm Chart
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [determine-version, create-release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Create Helm chart
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"

          # Create Helm chart structure
          helm create studyteddy-chart

          # Customize chart
          cat > studyteddy-chart/Chart.yaml << EOF
          apiVersion: v2
          name: studyteddy
          description: StudyTeddy Helm Chart
          type: application
          version: $VERSION
          appVersion: $VERSION
          keywords:
            - studyteddy
            - education
            - ai
          home: https://studyteddy.com
          sources:
            - https://github.com/${{ github.repository }}
          maintainers:
            - name: StudyTeddy Team
              email: team@studyteddy.com
          EOF

          # Customize values.yaml
          cat > studyteddy-chart/values.yaml << EOF
          replicaCount: 2

          image:
            backend:
              repository: ghcr.io/${{ github.repository }}/backend
              pullPolicy: IfNotPresent
              tag: "v$VERSION"
            frontend:
              repository: ghcr.io/${{ github.repository }}/frontend
              pullPolicy: IfNotPresent
              tag: "v$VERSION"

          service:
            type: ClusterIP
            port: 80

          ingress:
            enabled: true
            className: "nginx"
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
            hosts:
              - host: studyteddy.com
                paths:
                  - path: /
                    pathType: Prefix
            tls:
              - secretName: studyteddy-tls
                hosts:
                  - studyteddy.com

          resources:
            backend:
              limits:
                cpu: 1000m
                memory: 2Gi
              requests:
                cpu: 200m
                memory: 512Mi
            frontend:
              limits:
                cpu: 500m
                memory: 1Gi
              requests:
                cpu: 100m
                memory: 256Mi

          autoscaling:
            enabled: true
            minReplicas: 2
            maxReplicas: 10
            targetCPUUtilizationPercentage: 80

          nodeSelector: {}
          tolerations: []
          affinity: {}

          postgresql:
            enabled: false
            external:
              host: ""
              username: studyteddy
              database: studyteddy
              existingSecret: studyteddy-db-secret

          redis:
            enabled: false
            external:
              host: ""
              port: 6379
              existingSecret: studyteddy-redis-secret
          EOF

          # Package chart
          helm package studyteddy-chart --version $VERSION --app-version $VERSION

      - name: Upload Helm chart to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: studyteddy-${{ needs.determine-version.outputs.version }}.tgz
          asset_name: studyteddy-${{ needs.determine-version.outputs.version }}.tgz
          asset_content_type: application/gzip

  # Update package.json version
  update-version:
    name: Update Package Version
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [determine-version, create-release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Update package.json versions
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"

          # Update root package.json
          jq ".version = \"$VERSION\"" package.json > package.json.tmp && mv package.json.tmp package.json

          # Update workspace package.json files
          find apps packages -name "package.json" -type f | while read -r package_file; do
            jq ".version = \"$VERSION\"" "$package_file" > "$package_file.tmp" && mv "$package_file.tmp" "$package_file"
          done

      - name: Create version bump commit
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"

          git add package.json apps/*/package.json packages/*/package.json
          git commit -m "chore: bump version to v$VERSION" || exit 0
          git push origin main

  # Deploy to staging automatically
  deploy-staging:
    name: Deploy to Staging
    uses: ./.github/workflows/cd.yml
    needs: [determine-version, build-artifacts]
    if: needs.determine-version.outputs.is_prerelease == 'false'
    secrets: inherit
    with:
      environment: staging
      version: v${{ needs.determine-version.outputs.version }}

  # Create deployment tracking issue
  create-deployment-issue:
    name: Create Deployment Tracking Issue
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [determine-version, create-release, deploy-staging]
    if: always() && needs.create-release.result == 'success'

    steps:
      - name: Create deployment tracking issue
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.determine-version.outputs.version }}';
            const releaseUrl = '${{ needs.create-release.outputs.release_url }}';
            const stagingResult = '${{ needs.deploy-staging.result }}';

            const issueTitle = `🚀 Deployment Tracking: v${version}`;
            const issueBody = `
            ## Release v${version} Deployment Tracking

            **Release URL:** ${releaseUrl}

            ### Deployment Status

            - [x] 📦 Release created
            - [${stagingResult === 'success' ? 'x' : ' '}] 🧪 Staging deployment ${stagingResult}
            - [ ] 🔍 Staging validation
            - [ ] 🚀 Production deployment
            - [ ] ✅ Production validation
            - [ ] 📊 Performance verification
            - [ ] 📈 Monitoring alerts configured

            ### Deployment Checklist

            #### Pre-Production
            - [ ] Staging environment smoke tests passed
            - [ ] Performance benchmarks met
            - [ ] Security scans completed
            - [ ] Database migrations verified
            - [ ] Feature flags configured

            #### Production Deployment
            - [ ] Production deployment initiated
            - [ ] Health checks passed
            - [ ] Database migrations applied
            - [ ] CDN cache cleared
            - [ ] Monitoring alerts active

            #### Post-Deployment
            - [ ] Production smoke tests passed
            - [ ] Performance metrics within SLA
            - [ ] Error rates normal
            - [ ] User acceptance testing completed
            - [ ] Documentation updated

            ### Rollback Plan
            - Previous version: v${{ needs.determine-version.outputs.previous_version }}
            - Rollback command: \`./scripts/deployment/deploy-kubernetes.sh rollback v${{ needs.determine-version.outputs.previous_version }}\`

            **Assigned to:** @${{ github.actor }}
            **Created by:** GitHub Actions
            `;

            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['deployment', 'release', `v${version}`],
              assignees: ['${{ github.actor }}']
            });

            console.log(`Created deployment tracking issue: ${issue.html_url}`);

  # Notifications
  notify-release:
    name: Notify Release
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [determine-version, create-release, build-artifacts, deploy-staging]
    if: always()

    steps:
      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            ${{ needs.create-release.result == 'success' && '🎉' || '❌' }} **StudyTeddy Release v${{ needs.determine-version.outputs.version }}**

            **Status:** ${{ needs.create-release.result == 'success' && 'Released' || 'Failed' }}
            **Type:** ${{ needs.determine-version.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable' }}
            **Version:** v${{ needs.determine-version.outputs.version }}
            **Previous:** v${{ needs.determine-version.outputs.previous_version }}
            **Released by:** ${{ github.actor }}

            **Deployment Status:**
            - Staging: ${{ needs.deploy-staging.result || 'skipped' }}
            - Production: Pending manual approval

            **Release URL:** ${{ needs.create-release.outputs.release_url }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Discord
        if: always() && secrets.DISCORD_WEBHOOK_URL != ''
        uses: Ilshidur/action-discord@master
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          args: |
            🎉 **StudyTeddy v${{ needs.determine-version.outputs.version }} Released!**

            **Status:** ${{ needs.create-release.result }}
            **Staging Deployment:** ${{ needs.deploy-staging.result || 'skipped' }}
            **Release Notes:** ${{ needs.create-release.outputs.release_url }}